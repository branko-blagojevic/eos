#!/usr/bin/env python3

# Sample backup and restore utility that simply backs up EOS files iunder /eos/pathName
# to local directories /BackupPrefix.something

# eos -backup-test clone -B /BackupPrefix [-P <parentId>] /eos/pathName
#   - performs the actual clone, based on parentId or full, creates catalogFile
#     Outputs "cloneId <cloneId> catalog <catalogFile>"
#
# eos-backup-test backup -B /BackupPrefix [-F catalogFile] [-P <parentId>] /eos/pathName
#   - unless specified with '-F' uses "clone" to produce a clone and catalogFile
#     and then backs up files into /BackupPrefix.cloneId and deletes the clone.
#     Outputs "cloneId <cloneId> backup media <backupDir>" followed by whatever
#     the deletion of the clone says.
#
# eos-backup-test restore -B /BackupPrefix -F /inputCatalog1[,/inputCatalog2[,...]] /outputDirectory
#   - performs a restore into outputDirectory based on 1 or more catalogFiles

# for clone/backup the data are stored in /BackupPrefix.cloneId and /BackupPrefix.cloneId.catalog
# the /eos pathnames are as seen by the MGM, not necessarily fuse-mounted paths in the local file system

# environment:
#   EOS_MGM_URL=root://eos-mgm-test.eoscluster.cern.ch must point to the MGM serving /eos/pathName

# A primitive full_backup-make_changes-incremental_backup-restore example in bash:

#   # full clone and backup in one go
#   read xx cloneId1 xx <<<$(eos-backup-test backup -B /tmp/Backup /eos/dockertest/backuptest)
#
#   : make some changes, delete/add/modify files
#
#   # an incremental clone based on first backup
#   read xx cloneId2 xx <<<$(eos-backup-test clone -B /tmp/Backup -P $cloneId1 /eos/dockertest/backuptest)
#
#   # back those files up
#   read xx cloneId2 xx <<<$(eos-backup-test backup -B /tmp/Backup -F /tmp/Backup.$cloneId2.catalog /eos/dockertest/backuptest)
#
#   # restore the lot
#   eos-backup-test restore -F /tmp/Backup.$cloneId1.catalog,/tmp/Backup.$cloneId2.catalog -B /tmp/Backup /tmp/Restore2

   

from __future__ import print_function

import getopt, os, sys, tempfile
import pdb

backupDirPrefix = "/tmp/backupDir"
try:
    eos_mgm_url = os.environ['EOS_MGM_URL']
    if eos_mgm_url == '': raise KeyError
except KeyError:
    print("need to define EOS_MGM_URL in the environment")
    sys.exit(1)

eos_instance = os.popen("eos version").readlines()[0].split('=')[1].rstrip()

# create the clone, results in a catalogFile
def do_clone(args):
    global backupDirPrefix
    parentId = 10
    opts, args = getopt.getopt(args, "B:P:")
    for opt in opts:
      if opt[0] == '-B':
        backupDirPrefix = opt[1]
      elif opt[0] == '-P':
        try:
            parentId = int(opt[1])
        except ValueError:
            print("invalid parent Id")
            sys.exit(22)

    catalogFile = tempfile.mkstemp(prefix=backupDirPrefix)
    
    try:
        f = os.fdopen(catalogFile[0], "w")
    except IOError as e:
        print("cannot open %s: %s" % (catalogFile[1], e.message))
        sys.exit(5)

    cmd = "eos find -f -x sys.clone=+%d %s" % (parentId, args[0])
    findOut = os.popen(cmd).readlines()

    (rootPath, ttt) = findOut[0].split(' ')	# the rootPath includes the trailing '/'
    cloneInfo = ttt.split(':')
    cloneId = cloneInfo[1]

    # write the output to newCatFile and rename
    for l in findOut: f.write(l)
    f.close()
    newCatFile = "%s.%s.catalog" % (backupDirPrefix, cloneId)
    os.rename(catalogFile[1], newCatFile)
    print("cloneId %s catalog %s" % (cloneId, newCatFile))

    return cloneId

# perform a clone unless a catalogFile has been given, then back up files
def do_backup(args):
    global backupDirPrefix
    opts, args = getopt.getopt(args, "F:B:")
    catalogFile = None
    for opt in opts:
        if   opt[0] == '-B': backupDirPrefix = opt[1]
        elif opt[0] == '-F': catalogFile = opt[1]

    if catalogFile is None:
        cloneId = do_clone(args)
        catalogFile = "%s.%s.catalog" % (backupDirPrefix, cloneId)
    
    try:
        f = open(catalogFile, "r")
    except IOError as e:
        print("cannot open %s: %s" % (catalogFile, e.message))
        sys.exit(5)

    findOut = f.readlines()

    (rootPath, ttt) = findOut[0].split(' ')	# the rootPath includes the trailing '/'
    cloneInfo = ttt.split(':')
    cloneId = cloneInfo[1]

    backupDir = "%s.%s/" % (backupDirPrefix, cloneId)
    cloneDir = "/eos/%s/proc/clone/" % (eos_instance)

    print("cloneId %s backup media %s" % (cloneId, backupDir))

    for l in findOut:
        path, cloneInfo = l.split()
        rpath = path[len(rootPath):]	# skip the "root" part
        if path.endswith('/'): 		    # this is a directory
            os.makedirs(backupDir + rpath)
        else:				            # this is a file
            stime, clonePath = cloneInfo.split(':')[0:2]
            fCloneId = clonePath.split('/')[0]
            if fCloneId != cloneId: continue		# file has not been modified in incremental dump
            cpath = cloneDir + clonePath

            # try copy the clone first
            cmd1 = "xrdcp %s/%s %s/%s 2>&1" % (eos_mgm_url, cpath, backupDir, rpath)
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc > 256: rc = rc >> 8		# recover xrdcp return code

            if rc > 0:
                # copy the live file
                cmd2 = "xrdcp %s/%s %s/%s 2>&1" % (eos_mgm_url, path, backupDir, rpath)
                p2 = os.popen(cmd2)
                x2 = p2.readlines()
                rc = p2.close()
                if rc > 256: rc = rc >> 8	# recover xrdcp return code

            # retry then clone if created in the meantime
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc > 256: rc = rc >> 8		# recover xrdcp return code
	    
	    
    f.close()

    cmd = "eos find -f -x sys.clone=-%s %s > /dev/null" % (cloneId, args[0])
    os.system(cmd)

# perform a restore based on multiple catalogFiles
def do_restore(args):
    #pdb.set_trace()
    global backupDirPrefix
    opts, args = getopt.getopt(args, "B:F:P:")
    trg = args[0] + "/"
    for opt in opts:
        if opt[0] == '-F': catalogFiles = opt[1].split(',')
        elif opt[0] == '-B': backupDirPrefix = opt[1]

    cat = dict()

    backupDirPrefix = '.'.join(catalogFiles[0].split('.')[:-2])

    # build a dictionary of files to be restored, implementing the logic to select most recent files
    for fn in catalogFiles:
        lastCatFile = fn == catalogFiles[-1]

        ff = open(fn, "r").readlines()
        (rootPath, ttt) = ff[0].split(' ')	# the rootPath includes the trailing '/'
        cloneInfo = ttt.split(':')
        cloneId = cloneInfo[1]

        for l in ff:
            path, ttt = l.split(' ')
            rpath = path[len(rootPath):]	# skip the "root" part
            stime, clonePath = ttt.split(":")[0:2]

            if rpath in cat:
                if stime < cat[rpath]['stime'] or clonePath.startswith('0'):    # file exists but not part of this backup
                    if lastCatFile: cat[rpath]['keep'] = True
                    continue		# restore latest version
            else: cat[rpath] = dict()
            cat[rpath]['stime'] = stime
            cat[rpath]['cloneId'] = cloneId
            if lastCatFile: cat[rpath]['keep'] = True


    # restore files
    for p in sorted(cat.keys()):	# sorted so that dirs come before their files
        if not 'keep' in cat[p]: continue
        if p.endswith('/') or p == '':  # a directory
            os.makedirs(trg + p)
        else:
            # restore the file trg/p form the backup directory
            cmd = "cp %s.%s/%s %s/%s" % (backupDirPrefix, cat[p]['cloneId'], p, trg, p)
            os.system(cmd)

# main
try:
  #pdb.set_trace()
  if sys.argv[1] == 'clone':
    do_clone(sys.argv[2:])
  elif sys.argv[1] == 'backup':
    do_backup(sys.argv[2:])
  elif sys.argv[1] == 'restore':
    do_restore(sys.argv[2:])
  else:
    raise NameError
  sys.exit(0)
except (IndexError, NameError) as e:
  print("incorrect argument", "" if type(e) == type(IndexError()) else sys.argv[1])
  sys.exit(1)
