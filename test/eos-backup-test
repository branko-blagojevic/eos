#!/usr/bin/env python3

# Sample backup and restore utility that simply backs up EOS files iunder /eos/pathName
# to local directories /BackupPrefix.something

# eos -backup-test clone -B /BackupPrefix [-P <parentId>] /eos/pathName
#   - performs the actual clone, based on parentId or full, creates catalogFile
#     Outputs "cloneId <cloneId> catalog <catalogFile>"
#
# eos-backup-test backup -B /BackupPrefix [-F catalogFile] [-P <parentId>] /eos/pathName
#   - unless specified with '-F' uses "clone" to produce a clone and catalogFile
#     and then backs up files into /BackupPrefix.cloneId and deletes the clone.
#     Outputs "cloneId <cloneId> backup media <backupDir>" followed by whatever
#     the deletion of the clone says.
#
# eos-backup-test restore -B /BackupPrefix -F /inputCatalog1[,/inputCatalog2[,...]] /outputDirectory
#   - performs a restore into outputDirectory based on 1 or more catalogFiles

# for clone/backup the data are stored in /BackupPrefix.cloneId and /BackupPrefix.cloneId.catalog
# the /eos pathnames are as seen by the MGM, not necessarily fuse-mounted paths in the local file system

# environment:
#   EOS_MGM_URL=root://eos-mgm-test.eoscluster.cern.ch must point to the MGM serving /eos/pathName

# A primitive full_backup-make_changes-incremental_backup-restore example in bash:

#   # full clone and backup in one go
#   read xx cloneId1 xx <<<$(eos-backup-test backup -B /tmp/Backup /eos/dockertest/backuptest)
#
#   : make some changes, delete/add/modify files
#
#   # an incremental clone based on first backup
#   read xx cloneId2 xx <<<$(eos-backup-test clone -B /tmp/Backup -P $cloneId1 /eos/dockertest/backuptest)
#
#   # back those files up
#   read xx cloneId2 xx <<<$(eos-backup-test backup -B /tmp/Backup -F /tmp/Backup.$cloneId2.catalog /eos/dockertest/backuptest)
#
#   # restore the lot
#   eos-backup-test restore -F /tmp/Backup.$cloneId1.catalog,/tmp/Backup.$cloneId2.catalog -B /tmp/Backup /tmp/Restore2

   

from __future__ import print_function

import getopt, json, os, sys, tempfile
import pdb

use_json='-j'       # -f text, -j json backup files

# options
subcmd = sys.argv[1]
opts, args = getopt.getopt(sys.argv[2:], "B:F:P:U:")

# default backupDirPrefix and parentId
dflt = [('-B', "/tmp/backupDir"),('-P', 10)]

# resulting options
opt = dict(dflt+opts)

if '-P' in opt:
    try:
        parentId = int(opt['-P'])
    except ValueError:
            print("invalid parent Id")
            sys.exit(22)

if '-U' not in opt:
    try:
        opt['-U'] = os.environ['EOS_MGM_URL']
        if opt['-U'] == '': raise KeyError
    except KeyError:
        print("need to specify 'U' or define EOS_MGM_URL in the environment")
        sys.exit(1)

eos_instance = os.popen("eos version").readlines()[0].split('=')[1].rstrip()

# create the clone, results in a catalogFile
def do_clone():
    catalogFile = tempfile.mkstemp(prefix=opt['-B'])
    
    try:
        f = os.fdopen(catalogFile[0], "w")
    except IOError as e:
        print("cannot open %s: %s" % (catalogFile[1], e.message))
        sys.exit(5)
    f.close()

    try:
      cmd = "eos find %s -x sys.clone=+%d %s > %s" % (use_json, int(opt['-P']), args[0], catalogFile[1])
      os.system(cmd);
    except:
        print("Unexpected error:", sys.exc_info()[0])
        print("cmd:", cmd)
        raise

    line1 = open(catalogFile[1]).readline()

    if use_json == '-j':
        xx = json.loads(line1)
        cloneId = xx['c']
    else:
        (rootPath, ttt) = line1.split(' ')	# the rootPath includes the trailing '/'
        cloneInfo = ttt.split(':')
        cloneId = cloneInfo[1]

    newCatFile = "%s.%s.catalog" % (opt['-B'], cloneId)
    os.rename(catalogFile[1], newCatFile)
    print("cloneId %s catalog %s" % (cloneId, newCatFile))

    return cloneId

# perform a clone unless a catalogFile has been given, then back up files
def do_backup():
    if '-F' in opt:
        catalogFile = opt['-F']
    else:
        cloneId = do_clone()
        catalogFile = "%s.%s.catalog" % (opt['-B'], cloneId)
    
    try:
        f = open(catalogFile, "r")
    except IOError as e:
        print("cannot open %s: %s" % (catalogFile, e.message))
        sys.exit(5)

    #findOut = f.readlines()
    line1 = f.readline()

    if use_json == '-j':
        xx = json.loads(line1)
        cloneId = xx['c']
        rootPath = xx['n']
    else:
        (rootPath, ttt) = line1.split(' ')	# the rootPath includes the trailing '/'
        cloneInfo = ttt.split(':')
        cloneId = cloneInfo[1]

    backupDir = "%s.%s/" % (opt['-B'], cloneId)
    cloneDir = "/eos/%s/proc/clone/" % (eos_instance[3:] if eos_instance.startswith("eos") else eos_instance)

    print("cloneId %s backup media %s" % (cloneId, backupDir))

    #for l in findOut:    .... what about first line?
    while True:
        l = f.readline()
        if len(l) == 0: break

        if use_json == '-j':
            xx = json.loads(l)
            fCloneId = xx['c']              # id of clone the file belongs to, might be an earier dump than this one
            path = xx['n']
            if not path.endswith('/'): 		# this is a file
                clonePath = "%s/%s" % (fCloneId, xx['p'])
            stime = xx['t']
        else:
            path, cloneInfo = l.split()
            if not path.endswith('/'):  # a file
                stime, clonePath = cloneInfo.split(':')[0:2]
                fCloneId = clonePath.split('/')[0]

        rpath = path[len(rootPath):]	# skip the "root" part

        if path.endswith('/'): 		    # this is a directory
            os.makedirs(backupDir + rpath)
        else:				            # this is a file
            if fCloneId != cloneId: continue		# file has not been modified in incremental dump
            cpath = cloneDir + clonePath

            # try copy the clone first
            cmd1 = "xrdcp %s/%s %s%s 2>&1" % (opt['-U'], cpath, backupDir, rpath)
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc is None: rc = 0
            elif rc > 256: rc = rc >> 8		# recover xrdcp return code

            if rc > 0:
                # copy the live file
                cmd2 = "xrdcp %s/%s %s%s 2>&1" % (opt['-U'], path, backupDir, rpath)
                p2 = os.popen(cmd2)
                x2 = p2.readlines()
                rc = p2.close()
                if rc is None: rc = 0
                elif rc > 256: rc = rc >> 8	# recover xrdcp return code

            # retry then clone if created in the meantime
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc is None: rc = 0
            elif rc > 256: rc = rc >> 8		# recover xrdcp return code
	    
	    
    f.close()

    cmd = "eos find -f -x sys.clone=-%s %s > /dev/null" % (cloneId, args[0])
    os.system(cmd)

# perform a restore based on multiple catalogFiles
def do_restore():
    #pdb.set_trace()
    trg = args[0] + "/"
    catalogFiles = opt['-F'].split(',')

    cat = dict()

    backupDirPrefix = '.'.join(catalogFiles[0].split('.')[:-2])

    # build a dictionary of files to be restored, implementing the logic to select most recent files
    for fn in catalogFiles:
        lastCatFile = fn == catalogFiles[-1]

        ff = open(fn, "r")
        line1 = ff.readline()
        if use_json == '-j':
            xx = json.loads(line1)
            cloneId = xx['c']
            rootPath = xx['n']
        else:
            (rootPath, ttt) = line1.split(' ')	# the rootPath includes the trailing '/'
            cloneInfo = ttt.split(':')
            cloneId = cloneInfo[1]

        ff.seek(0,0)                            # rewind

        while True:
            l = ff.readline()
            if l is '': break

            if use_json == '-j':
                try:
                    xx = json.loads(l)
                except json.decoder.JSONDecodeError as e:
                    print("json error %r l='%s'" % (e, l), file=sys.stderr)
                    sys.exit(1)

                path = xx['n']
                stime = xx['t']
                if not path.endswith('/'): clonePath = "%s/%s" % (xx['c'], xx['p'])
            else:
                path, ttt = l.split(' ')
                stime, clonePath = ttt.split(":")[0:2]

            rpath = path[len(rootPath):]	# skip the "root" part
            if rpath in cat and not path.endswith('/'):
                if stime < cat[rpath]['stime'] or clonePath.startswith('0'):    # file exists but not part of this backup
                    if lastCatFile: cat[rpath]['keep'] = True
                    continue		# restore latest version
            else: cat[rpath] = dict()

            cat[rpath]['stime'] = stime
            cat[rpath]['cloneId'] = cloneId
            if lastCatFile: cat[rpath]['keep'] = True


    # restore files
    for p in sorted(cat.keys()):	# sorted so that dirs come before their files
        if not 'keep' in cat[p]: continue
        if p.endswith('/') or p == '':  # a directory
            os.makedirs(trg + p)
        else:
            # restore the file trg/p form the backup directory
            cmd = "cp %s.%s/%s %s/%s" % (backupDirPrefix, cat[p]['cloneId'], p, trg, p)
            os.system(cmd)

# main
try:
  #pdb.set_trace()
  if subcmd == 'clone':
    do_clone()
  elif subcmd == 'backup':
    do_backup()
  elif subcmd == 'restore':
    do_restore()
  else:
    raise NameError
  sys.exit(0)
except (IndexError, NameError) as e:
  print("incorrect argument", "" if type(e) == type(IndexError()) else subcmd)
  sys.exit(1)
